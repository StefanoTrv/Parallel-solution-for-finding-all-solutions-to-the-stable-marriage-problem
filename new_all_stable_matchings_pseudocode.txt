ALL_STABLE_MATCHINGS(n, men_preferences, women_preferences):
	top_matching = GALE_SHAPLEY(n, men_preferences, women_preferences)
	
	//da creare il grafo delle rotazioni direttamente o a partire dalla lista
	free_rotations_list = FIND_ALL_ROTATIONS(men_preferences, women_preferences, n)
	//serve ricavare anche la lista dei nodi liberi, cioè i nodi del grafo che non hanno predecessori
	//free_rotations_list è questa lista di nodi
	
	results_list = NEW_LIST()
	results_list.append(top_matching)
	
	RECURSIVE_SEARCH(top_matching,n,free_rotations_list,results_tree)
	
	return results_tree
	
RECURSIVE_SEARCH(matching,n,free_rotations_list,results_list):
	while free_rotations_list != NULL:
		
		//applica la rotazione
		rotation = free_rotations_list.value.value //ricavo la rotazione nel nodo in quell'elemento della lista
		
		first_woman = rotation.value[1]
		while rotation.next!=NULL:
			matching[rotation.value[0]]=rotation.next.value[1]
			rotation = rotation.next
		matching[rotation.value[0]]=first_woman
		
		//aggiungo il matching ai risultati
		new_matching = int[n]
		for i=0; i<n; i++:
			new_matching[i]=matching[i]
		results_list.append(new_matching)
		
		//creo la nuova lista delle rotazioni per la chiamata ricorsiva
		//tolgo la rotazione applicata e aggiungo quelle nuove rotazioni
		new_free_rotations_list = free_rotations_list.next
		for successor in free_rotations_list.value.successors:
			successor.missing_predecessors -= 1
			if successor.missing_predecessors == 0:
				//aggiungi questa rotazione in cima lista
				new_list_el = NEW_LIST_ELEMENT()
				new_list_el.value = successor
				new_list_el.next = new_free_rotations_list
				new_free_rotations_list = new_list_el
		
		//chiamata ricorsiva
		RECURSIVE_SEARCH(matching,n,new_free_rotations_list,results_list)
		
		//ripristino le rotazioni
		//ripristino i missing_predecessors dei successori
		for successor in free_rotations_list.value.successors:
			successor.missing_predecessors += 1
		//Attenzione alle memory leak!
		//Qui non liberiamo esplicitamente la memoria allocata per i nuovi elementi di new_free_rotations_list.
		//Se necessario, si può fare in O(n) con qualche piccola modifica.
		
		//ripristina rotazione
		rotation = free_rotations_list.value.value
		while rotation.next!=NULL:
			matching[rotation.value[0]]=rotation.value[1]
			rotation = rotation.next
		
		free_rotations_list = free_rotations_list.next //ad ogni iterazione, togliamo una rotazione dalla lista