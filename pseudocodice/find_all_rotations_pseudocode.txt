FIND_ALL_ROTATIONS(men_preferences, women_preferences, n):
	free_rotations_list = NEW_EMPTY_LIST()
	last_to_have_modified = NODE[n] //vettore di puntatori all'ultimo nodo che ha modificato l'uomo/donna
	m_i = GALE-SHAPLEY(n,men_preferences,women_preferences)
	bottom_matching = GALE-SHAPLEY(n,women_preferences,men_preferences)
	marking = int[n] //-1 = unmarked, n è marked ma senza niente associato, altri sono la donna precedente
	rotation_index = 0 //per indicizzare le rotazioni su already_added_predecessors
	already_added_predecessors = bool[n*n] //per ridurre il numero di archi nel grafo delle rotazioni
	for j=0; j<n*n:
		already_added_predecessors[j]=False
	for j=0; j<n:
		marking[j]=-1
		last_to_have_modified[j]=NULL
	men_preferences_indexes = int[n]
	for j=0; j<n:
		k = 0
		while men_preferences[k]!=m_i[j]:
			k++
		men_preferences_indexes[j]=k
	
	while True:
		//STEP 1
		m = -1
		for j = 0; j<n: //troviamo il primo uomo diverso tra m_i e bottom_matching
			if m_i[j]!=bottom_matching[j]:
				m = j
				break
		if m<0: // m_i == bottom_matching
			break
		
		//STEP 2
		w = m_i[m]
		marking[w]=n
		BREAKMARRIAGE(m_i,m,n,men_preferences,men_preferences_indexes,women_preferences,marking,free_rotations_list,last_to_have_modified,*rotation_index,already_added_predecessors)
	
	return free_rotations_list.first

BREAKMARRIAGE(M, m, n, men_preferences, men_preferences_indexes, women_preferences, marking, free_rotations_list, last_to_have_modified, *rotation_index,already_added_predecessors):
	i = 0
	while men_preferences[m][i]!=M[m]
		i++
	men_preferences_indexes[m]=i+1
	former_wife = M[m] //il w dell'articolo, donna con cui l'uomo è accoppiato e si deve separare
	reversed_M = int[n]
	old_reversed_M = int[n]
	for i = 0; i< n:
		reversed_M[M[i]]=i
		old_reversed_M[M[i]]=i
	previous_woman = n
	
	while True do
		breakmarriage_fail = True
		//itero sulle preferenze di m
		//m diventa m' dell'articolo all'iterno del ciclo
		for i = men_preferences_indexes[m]; i < n do
			w = men_preferences[m][i] //il w' dell'articolo
			//prendo m1 (attuale compagno di w) e lo confronto con m
			m1 = reversed_M[w]
			//se w preferisce m a m1, sciolgo (w,m1) e creo (w,m)
			if marking[w]<0 and TEST(women_preferences, n, w, m, m1): //step 2a
				k = men_preferences_indexes[m] //aggiorniamo indice per efficienza
				while men_preferences[k]!=w:
					k++
				men_preferences_indexes[m]=k
				reversed_M[w] = m
				marking[w] = previous_woman
				previous_woman = w
				m=m1 //nuovo uomo non accoppiato
				break
			else if TEST(women_preferences, n, w, m, old_reversed_M[w]): //step 2b
				old_marking = marking[w]
				PAUSE_BREAKMARRIAGE(marking, M, reversed_M, old_reversed_M, free_rotations_list, w, previous_woman,last_to_have_modified,*rotation_index,already_added_predecessors)
				if former_wife == w: //3c: w = w'
					reversed_M[w] = m
					return //al passo 1
				else: //3d
					if TEST(women_preferences, n, w, m, m1):
						m = m1
						breakmarriage_fail = False
						break
					else:
						marking[w]=old_marking
						continue
		if breakmarriage_fail://non abbiamo trovato un accoppiamento stabile per m
			return

PAUSE_BREAKMARRIAGE(marking, M, reversed_M, old_reversed_M, free_rotations_list, w, previous_woman,last_to_have_modified, *rotation_index,already_added_predecessors): //w è w' dell'articolo
	no_predecessors = True
	prev_list_el = NULL
	w2 = w
	go_on = True
	rotation_node = NEW_NODE()
	rotation_node.missing_predecessors = 0
	rotation_node.index = *rotation_index
	*rotation_index += 1
	predecessors_list = NEW_LIST() //i predecessori del nodo che stiamo creando, per poter resettare already_added_predecessors
	while w2!=w and go_on:
		go_on = w2==w
		//costruire lista della rotazione dalla coda alla testa
		list_el = NEW_LIST_EL()
		list_el.value = (old_reversed_M[w2],w2)
		list_el.next = prev_list_el
		prev_list_el = list_el
		//aggiorniamo predecessori e last_to_have_modified
		new_successor = NEW_LIST_EL()
		new_successor.value = rotation_node
		if last_to_have_modified[old_reversed_M[w2]]!=NULL and not already_added_predecessors[last_to_have_modified[old_reversed_M[w2]].index]: //aggiungiamo la rotazione solo una volta ad ogni predecessore
			new_successor.next = last_to_have_modified[old_reversed_M[w2]].successors
			last_to_have_modified[old_reversed_M[w2]].successors = new_successor
			no_predecessors = False
			rotation_node.missing_predecessors += 1
			already_added_predecessors[last_to_have_modified[old_reversed_M[w2]].index] = True
			predecessors_list.append(last_to_have_modified[old_reversed_M[w2]])
		else:
			new_successor.next = NULL
		last_to_have_modified[old_reversed_M[w2]] = rotation_node
		//aggiorniamo old_reversed_M (i = i + 1)
		old_reversed_M[w2]=reversed_M[w2]
		//aggiorna M
		M[old_reversed_M[w2]]=w2
		//resettare marking
		marking[w2]=-1
		//update previous_woman
		w2 = previous_woman
		previous_woman = marking[w2]
		
	rotation_node.rotation = prev_list_el
	
	if no_predecessors:
		new_list_el = NEW_LIST_EL()
		new_list_el.value  = rotation_node
		free_rotations_list.append(new_list_el)
	
	//ripristiniamo already_added_predecessors
	list_el = predecessors_list.first
	while list_el != NULL:
		already_added_predecessors[list_el.value.index]=False
	
	//Se necessario, si liberi la memoria di predecessors_list
			
	return